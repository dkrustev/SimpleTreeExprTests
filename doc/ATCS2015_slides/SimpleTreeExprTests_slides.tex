\documentclass{beamer}

\usepackage{amsfonts} % for \mathbb{...}
\usepackage{stmaryrd} % for \llbracket, ...

\title{Finite Test Sets for a Class of Simple Programs on Binary Trees}
\author{Dimitur Krustev}

\pgfdeclareimage[height=0.7cm]{mylogo1}{IgeXaoLogo.png}

\institute[IGE+XAO Balkan]
{
  IGE+XAO Balkan \\ \vspace{0.3cm} \pgfuseimage{mylogo1}
}

\date[ATCS 2015]{12 June 2015 / ATCS 2015}

\begin{document}

\begin{frame}
\maketitle
\end{frame}

\begin{frame}[Outline]
  \tableofcontents
\end{frame}

\section{Preliminaries}

\subsection{Binary Trees as a Universal Data Structure}

\begin{frame}[Unlabeled Binary Trees]
  \frametitle{Unlabeled Binary Trees}
	\[ 
	T ~::=~ \texttt{nil} ~|~ (T ~.~ T)
	\]
  \begin{itemize}
    \item Universal data structure 
    \item built-in pairing (unlike natural numbers, bitstrings, \ldots)
    \item possible encodings:
    \begin{itemize}
	  \item $\lceil \bullet \rceil_{\text{Bool}} ~:~ \text{Bool} \rightarrow T$
	  \[
	    \begin{array}{cc}
	    \lceil \text{false} \rceil_{\text{Bool}} ~=~ \text{nil}
	    &
	    \lceil \text{true} \rceil_{\text{Bool}} ~=~ (\text{nil} ~.~ \text{nil})
	    \end{array}
	  \]
	  
	  \item $\lceil \bullet \rceil_{\mathbb{N}} ~:~ \mathbb{N} \rightarrow T$
	  \[
	    \begin{array}{cc}
	    \lceil 0 \rceil_{\mathbb{N}} ~=~ \text{nil}
	    &
	    \lceil n+1 \rceil_{\mathbb{N}} ~=~ (\text{nil} ~.~ \lceil n \rceil_{\mathbb{N}})
	    \end{array}
	  \]
	  
	  \item $\lceil \bullet \rceil_{\text{List}(X)} ~:~ \text{List}(X) \rightarrow T$
	  \[
	    \begin{array}{lcl}
	    \lceil \lbrack\rbrack \rceil_{\text{List}(X)} & ~=~ & \text{nil}
	    \\
	    \lceil \lbrack x_1, x_2, \ldots, x_n \rbrack \rceil_{\text{List}(X)} 
	      & ~=~ & (\lceil x_1 \rceil_{X} ~.~ \lceil \lbrack x_2, \ldots, x_n \rbrack \rceil_{\text{List}(X)})
	    \end{array}
	  \]
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Simple Programs on Binary Trees}

\begin{frame}
  \frametitle{Simple Programs on Binary Trees}
  \[ E ~::=~ \texttt{I} ~|~ \texttt{hd} ~|~ \texttt{tl} ~|~ \texttt{nil}
       ~|~ \texttt{cons}(E, E)
       ~|~ E \circ E
       ~|~ \texttt{ifnil}(E, E, E)  \]
  \begin{itemize}
    \item interpretation: functions from trees to trees 
      (extended with a distinct value $\perp$ denoting undefined interpretation)
  \end{itemize}
  \[
    \begin{array}{lcl}
    \llbracket \bullet \rrbracket & : & E \rightarrow T \rightarrow T_{\perp} \\
    \llbracket \texttt{I} \rrbracket(x) & = & x \\
    \llbracket \texttt{hd} \rrbracket(t_1 ~.~ t_2) & = & t_1 \\
    \llbracket \texttt{tl} \rrbracket(t_1 ~.~ t_2) & = & t_2 \\
    \llbracket \texttt{nil} \rrbracket(x) & = & \texttt{nil} \\
    \llbracket \texttt{cons}(e_1, e_2) \rrbracket(x) & = & 
        (\llbracket e_1 \rrbracket(x) ~.~ \llbracket e_2 \rrbracket(x)) \\
    \llbracket e_1 \circ e_2 \rrbracket(x) & = & 
        \llbracket e_1 \rrbracket(\llbracket e_2 \rrbracket(x)) \\
    \llbracket \texttt{ifnil}(e_1, e_2, e_3) \rrbracket(x) & = & 
        \llbracket e_2 \rrbracket(x) ~,~ \text{if} ~ \llbracket e_1 \rrbracket(x) = \texttt{nil} \\
    \llbracket \texttt{ifnil}(e_1, e_2, e_3) \rrbracket(x) & = & 
        \llbracket e_3 \rrbracket(x) ~,~ \text{if} ~ \llbracket e_1 \rrbracket(x) = (t_1 ~.~ t_2) \\
    \llbracket \ldots \rrbracket(\ldots) & = & \perp
    \end{array}  
  \]
  \begin{itemize}
    \item ``simple'' programs: no loops or recursion
  \end{itemize}
\end{frame}

\subsection{Program Normal Forms}

\begin{frame}
  \frametitle{Program Normal Forms}
  \[\begin{array}{lclr}
  E^{nf} & ~::=~ & \texttt{nil} ~|~ \texttt{cons}(E^{nf}, E^{nf}) & \\
         &       & ~|~ \mathit{Sel}_1 \circ \ldots \circ \mathit{Sel}_n & (n \ge 0) \\
         &       & ~|~ \texttt{ifnil}(\mathit{Sel}_1 \circ \ldots \circ \mathit{Sel}_n, E^{nf}, E^{nf}) & (n \ge 0) \\
  \mathit{Sel} & ~::=~ & \texttt{hd} ~|~ \texttt{tl} & 
  \end{array}
  \]
  
\end{frame}

\section{Finite Test Sets for Simple Programs}

\subsection{Program Classes by Composition Length}

\begin{frame}
  \frametitle{Program Classes by Composition Length}
  \[\begin{array}{lclr}
  E^{nf}_N & ~::=~ & \texttt{nil} ~|~ \texttt{cons}(E^{nf}_N, E^{nf}_N) & \\
         &       & ~|~ \mathit{Sel}_1 \circ \ldots \circ \mathit{Sel}_n & (0 \le n \le N) \\
         &       & ~|~ \texttt{ifnil}(\mathit{Sel}_1 \circ \ldots \circ \mathit{Sel}_n, E^{nf}_N, E^{nf}_N) & (0 \le n < N) \\
  \mathit{Sel} & ~::=~ & \texttt{hd} ~|~ \texttt{tl} & 
  \end{array}
  \]
  \pause
  \begin{itemize}
    \item $E^{nf}_N \subset E^{nf}_{N+1}$, $\bigcup_{N \in \mathbb{N}} E^{nf}_N = E^{nf}$
  \pause  
    \item \textbf{Main result}:
    $\forall N \in \mathbb{N}, \forall e_1, e_2 \in E^{nf}_N,$ 
    $(\forall t \in T_{N+1}, \llbracket e_1 \rrbracket (t) = \llbracket e_2 \rrbracket (t))$
    $\rightarrow \forall t \in T, \llbracket e_1 \rrbracket (t) = \llbracket e_2 \rrbracket (t)$, where:
  \end{itemize}
    \[\begin{array}{lcl}
    \mathit{depth} & ~:~ & T \rightarrow \mathbb{N} \\
    \mathit{depth}(\texttt{nil}) & ~=~ & 0 \\
    \mathit{depth}(t_1 ~.~ t_2) & ~=~ & 1 + \mathit{max}(\mathit{depth}(t_1), \mathit{depth}(t_2)) \\
    T_{N} & ~=~ & \{t \in T ~|~ \mathit{depth}(t) \le N \} 
    \end{array}
    \]
\end{frame}

\subsection{Tree Decomposition by Depth}

\subsection{Existence of Finite Test Sets}

\section{Applications, Future Work}

\subsection{Deciding Program Equivalence}

\subsection{Testing a Turing-complete Language}

\subsection{Related Work} % ???

\end{document}