\documentclass{beamer}

\usepackage{amsfonts} % for \mathbb{...}
\usepackage{stmaryrd} % for \llbracket, ...

\usepackage{tikz}
\usetikzlibrary{calc} % for (let \p1= ... in ...)

\title{Finite Test Sets for a Class of Simple Programs on Binary Trees}
\author{Dimitur Krustev}

\pgfdeclareimage[height=0.7cm]{mylogo1}{IgeXaoLogo.jpg}

\institute[IGE+XAO Balkan]
{
  IGE+XAO Balkan \\ \vspace{0.3cm} \pgfuseimage{mylogo1}
}

\date[ATCS 2015]{12 June 2015 / ATCS 2015}

\begin{document}

\begin{frame}
\maketitle
\end{frame}

\begin{frame}[Outline]
  \tableofcontents
\end{frame}

\section{Preliminaries}

\subsection{Binary Trees as a Universal Data Structure}

\begin{frame}[Unlabeled Binary Trees]
  \frametitle{Unlabeled Binary Trees}
	\[ 
	T ~::=~ \texttt{nil} ~|~ (T ~.~ T)
	\]
  \begin{itemize}
    \item Universal data structure 
    \item built-in pairing (unlike natural numbers, bitstrings, \ldots)
    \item possible encodings:
    \begin{itemize}
	  \item $\lceil \bullet \rceil_{\text{Bool}} ~:~ \text{Bool} \rightarrow T$
	  \[
	    \begin{array}{cc}
	    \lceil \text{false} \rceil_{\text{Bool}} ~=~ \text{nil}
	    &
	    \lceil \text{true} \rceil_{\text{Bool}} ~=~ (\text{nil} ~.~ \text{nil})
	    \end{array}
	  \]
	  
	  \item $\lceil \bullet \rceil_{\mathbb{N}} ~:~ \mathbb{N} \rightarrow T$
	  \[
	    \begin{array}{cc}
	    \lceil 0 \rceil_{\mathbb{N}} ~=~ \text{nil}
	    &
	    \lceil n+1 \rceil_{\mathbb{N}} ~=~ (\text{nil} ~.~ \lceil n \rceil_{\mathbb{N}})
	    \end{array}
	  \]
	  
	  \item $\lceil \bullet \rceil_{\text{List}(X)} ~:~ \text{List}(X) \rightarrow T$
	  \[
	    \begin{array}{lcl}
	    \lceil \lbrack\rbrack \rceil_{\text{List}(X)} & ~=~ & \text{nil}
	    \\
	    \lceil \lbrack x_1, x_2, \ldots, x_n \rbrack \rceil_{\text{List}(X)} 
	      & ~=~ & (\lceil x_1 \rceil_{X} ~.~ \lceil \lbrack x_2, \ldots, x_n \rbrack \rceil_{\text{List}(X)})
	    \end{array}
	  \]
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Simple Programs on Binary Trees}

\begin{frame}
  \frametitle{Simple Programs on Binary Trees}
  \[ E ~::=~ \texttt{I} ~|~ \texttt{hd} ~|~ \texttt{tl} ~|~ \texttt{nil}
       ~|~ \texttt{cons}(E, E)
       ~|~ E \circ E
       ~|~ \texttt{ifnil}(E, E, E)  \]
  \begin{itemize}
    \item interpretation: functions from trees to trees 
      (extended with a distinct value $\perp$ denoting undefined interpretation)
  \end{itemize}
  \[
    \begin{array}{lcl}
    \llbracket \bullet \rrbracket & : & E \rightarrow T \rightarrow T_{\perp} \\
    \llbracket \texttt{I} \rrbracket(x) & = & x \\
    \llbracket \texttt{hd} \rrbracket(t_1 ~.~ t_2) & = & t_1 \\
    \llbracket \texttt{tl} \rrbracket(t_1 ~.~ t_2) & = & t_2 \\
    \llbracket \texttt{nil} \rrbracket(x) & = & \texttt{nil} \\
    \llbracket \texttt{cons}(e_1, e_2) \rrbracket(x) & = & 
        (\llbracket e_1 \rrbracket(x) ~.~ \llbracket e_2 \rrbracket(x)) \\
    \llbracket e_1 \circ e_2 \rrbracket(x) & = & 
        \llbracket e_1 \rrbracket(\llbracket e_2 \rrbracket(x)) \\
    \llbracket \texttt{ifnil}(e_1, e_2, e_3) \rrbracket(x) & = & 
        \llbracket e_2 \rrbracket(x) ~,~ \text{if} ~ \llbracket e_1 \rrbracket(x) = \texttt{nil} \\
    \llbracket \texttt{ifnil}(e_1, e_2, e_3) \rrbracket(x) & = & 
        \llbracket e_3 \rrbracket(x) ~,~ \text{if} ~ \llbracket e_1 \rrbracket(x) = (t_1 ~.~ t_2) \\
    \llbracket \ldots \rrbracket(\ldots) & = & \perp
    \end{array}  
  \]
  \begin{itemize}
    \item ``simple'' programs: no loops or recursion
  \end{itemize}
\end{frame}

\subsection{Program Normal Forms}

\begin{frame}
  \frametitle{Program Normal Forms}
  \[\begin{array}{lclr}
  E^{nf} & ~::=~ & \texttt{nil} ~|~ \texttt{cons}(E^{nf}, E^{nf}) & \\
         &       & ~|~ \mathit{Sel}_1 \circ \ldots \circ \mathit{Sel}_n & (n \ge 0) \\
         &       & ~|~ \texttt{ifnil}(\mathit{Sel}_1 \circ \ldots \circ \mathit{Sel}_n, E^{nf}, E^{nf}) & (n \ge 0) \\
  \mathit{Sel} & ~::=~ & \texttt{hd} ~|~ \texttt{tl} & 
  \end{array}
  \]
  
\end{frame}

\section{Finite Test Sets for Simple Programs}

\subsection{Program Classes by Composition Length}

\begin{frame}
  \frametitle{Program Classes by Composition Length}
  \[\begin{array}{lclr}
  E^{nf}_N & ~::=~ & \texttt{nil} ~|~ \texttt{cons}(E^{nf}_N, E^{nf}_N) & \\
         &       & ~|~ \mathit{Sel}_1 \circ \ldots \circ \mathit{Sel}_n & (0 \le n \le N) \\
         &       & ~|~ \texttt{ifnil}(\mathit{Sel}_1 \circ \ldots \circ \mathit{Sel}_n, E^{nf}_N, E^{nf}_N) & (0 \le n < N) \\
  \mathit{Sel} & ~::=~ & \texttt{hd} ~|~ \texttt{tl} & 
  \end{array}
  \]
  \pause
  \begin{itemize}
    \item $E^{nf}_N \varsubsetneq E^{nf}_{N+1}$, $\bigcup_{N \in \mathbb{N}} E^{nf}_N = E^{nf}$
  \pause
    \item programs in $E^{nf}_N$ can only ``see'' at depth $\le N$ inside the input tree  
  \pause
    \item \textbf{Main result}:
    $\forall N \in \mathbb{N}, \forall e_1, e_2 \in E^{nf}_N,$ 
    $(\forall t \in T_{N+1}, \llbracket e_1 \rrbracket (t) = \llbracket e_2 \rrbracket (t))$
    $\rightarrow \forall t \in T, \llbracket e_1 \rrbracket (t) = \llbracket e_2 \rrbracket (t)$, where:
  \end{itemize}
    \[\begin{array}{lcl}
    \mathit{depth} & ~:~ & T \rightarrow \mathbb{N} \\
    \mathit{depth}(\texttt{nil}) & ~=~ & 0 \\
    \mathit{depth}(t_1 ~.~ t_2) & ~=~ & 1 + \mathit{max}(\mathit{depth}(t_1), \mathit{depth}(t_2)) \\
    T_{N} & ~=~ & \{t \in T ~|~ \mathit{depth}(t) \le N \} 
    \end{array}
    \]
\end{frame}

\subsection{Tree Decomposition by Depth}

\begin{frame}[fragile]
  \frametitle{Tree Decomposition by Depth}
  \begin{tikzpicture}[level/.style={sibling distance=60mm/#1}]
  \node[circle,draw] (root){$\bullet$}
    child {node (t1){$\vdots$}}
    child {node[circle,draw] (t2){$\bullet$}
      child {node[rectangle,draw,rounded corners] (t21){$\texttt{nil}$}}
      child {node (t22){$\vdots$}
        child {node[circle,draw] (t221){\only<1>{$\bullet$} \only<2>{$t_i$}}
          child {node (t2211){$\vdots$}}
          child {node (t2212){$\vdots$}}
        }
        child {node[circle,draw] (t222){\only<1>{$\bullet$} \only<2>{$t_j$}}
          child {node (t2221){$\vdots$}}
          child {node (t2222){$\vdots$}}
        }
      }
    };
  \draw [dotted] let \p1=(t1), \p2=(root), \p3=(t2222) in (\x1-5mm, \y2) -- (\x3+10mm, \y2);
  \draw [dotted] let \p1=(t1), \p2=(t221), \p3=(t2222) in (\x1-5mm, \y2) -- (\x3+10mm, \y2);
  \draw [<->] let \p1=(root), \p2=(t222), \p3=(t2222) in (\x3+5mm, \y1) -- node[right]{d} (\x3+5mm, \y2);
  \end{tikzpicture}
\end{frame}

\begin{frame}
  \frametitle{Tree Decomposition by Depth (cont.)}
  \begin{itemize}
    \item Trees with Variables:
	  \[
		T_X ~::=~ \texttt{nil} ~|~ (T_X ~.~ T_X) ~|~ x \qquad (x \in X)
	  \]
    \item Decomposition function: 
      $\mathit{cutAt} ~:~ \mathbb{N} \times T \rightarrow (X \rightarrow T) \times T_X$,
      $cutAt(d, t) = (\sigma, t_x)$, where:
      \begin{itemize}
	    \item $t_x$ is the tree $t$ with all nodes at depth $d$ replaced by variables from $X$
	    \item $\sigma$ is a substitution assigning the corresponding subtree to each of these variables
	  \end{itemize}
	\item Correctness of decomposition (\texttt{vCutAt\_mvSubst}): 
	  $\forall d \in \mathbb{N}, \forall t \in T, \forall \sigma, \forall t_x,$
	  $cutAt(d, t) = (\sigma, t_x) \rightarrow t_x \sigma = t$, where:
	  \[\begin{array}{lcl}
	    \texttt{nil} \sigma & = & \texttt{nil} \\
	    (t_1 ~.~ t_2) \sigma & = & (t_1 \sigma ~.~ t_2 \sigma) \\
	    x \sigma & = & \sigma(x)
	  \end{array}
	  \]
  \end{itemize}
\end{frame}

\subsection{Existence of Finite Test Sets}

\begin{frame}
  \frametitle{Conditionally Commuting Evaluation and Substitution}
  \begin{itemize}
    \item program evaluation straightforwardly extended to trees with variables
      (same rules):
      $\llbracket e \rrbracket_X ~:~ E \rightarrow T_X \rightarrow T_{X_\perp}$
    \item Key lemma (\texttt{ntmvEval\_ntEval}) -- we can switch the order of evaluation 
      and variable substitution, \emph{provided} no risk of hitting upon a variable
      during evaluation:
      $\forall N \in \mathbb{N}, \forall e \in E^{nf}_N, \forall X,$
      $\forall \sigma : X \rightarrow T, \forall t_x \in T_X,$
      $N \le \textit{minVarDepth}(t_x) \rightarrow$
      $\llbracket e \rrbracket(t_x\sigma) = (\llbracket e \rrbracket_X(t_x))\sigma$
      \begin{itemize}
        \item where:
        \[\begin{array}{lcl}
        \textit{minVarDepth}(\texttt{nil}) & = & \infty \\
        \textit{minVarDepth}(t_1 ~.~ t_2) & = & 1 + \textit{min}(\textit{minVarDepth}(t_1), \\
                                          &   &  \textit{minVarDepth}(t_2)) \\
        \textit{minVarDepth}(x) & = & 0
        \end{array}
        \]
        \item proof: induction on the structure of $e$
          \begin{itemize}
            \item condition $N \le \textit{minVarDepth}(t_x)$ used in key sub-cases
              to derive a contradiction
          \end{itemize}
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Trees with Variables Distinguishable by Shallow Substitutions}
  \begin{itemize}
    \item Another key lemma (\texttt{mvSubst\_discrim}) -- different trees 
      with variables can be distinguished by substituting trees of depth $\le 1$
      for the variables:
      $\forall X, \forall t_1, t_2 \in T_X, t_1 \neq t_2 \rightarrow$
      $\exists \sigma, (\forall x\in X, \sigma(x) \in T_1)$
      $\wedge t_1 \sigma \neq t_2 \sigma$
    \begin{itemize}
      \item Proof sketch: there must be at least one pair of corresponding 
        subtrees $t_1'$ and $t_2'$ with different root nodes
      \begin{itemize}
        \item if neither root is a variable, then the trivial substitution will do:
          $\sigma(x) = \texttt{nil}, \forall x \in X$
        \item if only one root is a variable -- say $x$ -- we select
          $\sigma(x) = \texttt{nil}$ or $\sigma(x) = (\texttt{nil} ~.~ \texttt{nil})$
          depending on the kind of the other root
        \item if $t_1' = x, t_2' = y$, then we can use:
          \[\begin{array}{lclr}
          \sigma(x) & = & \texttt{nil} & \\
          \sigma(y) & = & (\texttt{nil} ~.~ \texttt{nil}) & \\
          \sigma(z) & = & \texttt{nil} & \forall z \in X, z \neq x, z \neq y
          \end{array}
          \]
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Existence of Finite Test Sets}
  \begin{itemize}
    \item Main result, in contrapositive form (\texttt{NTrm\_fixed\_MaxSelCmpLen\_testable\_aux}):
      $\forall N, \forall e_1, e_2 \in E^{nf}_N,$
      $(\exists t \in T, \llbracket e_1 \rrbracket (t) \neq \llbracket e_2 \rrbracket (t))$
      $\rightarrow$
      $\exists t \in T_{N+1}, \llbracket e_1 \rrbracket (t) \neq \llbracket e_2 \rrbracket (t)$
      \pause
	  \begin{itemize}
	    \item Proof sketch: let $t \in T$, s.t. $\llbracket e_1 \rrbracket (t) \neq \llbracket e_2 \rrbracket (t)$
	    \pause
	    \item let $(\sigma, t_x) = \mathit{cutAt}(N, t)$
	    \item then $\llbracket e_1 \rrbracket (t_x \sigma) \neq \llbracket e_2 \rrbracket (t_x \sigma)$
	    \pause
	    \item commute evaluation and substitution: 
	      $(\llbracket e_1 \rrbracket_X (t_x))\sigma \neq (\llbracket e_2 \rrbracket_X (t_x)) \sigma$
	      \begin{itemize}
	        \item possible because $\mathit{cutAt}(N, t) = (\sigma, t_x)$
			  ensures that $N \le \textit{minVarDepth}(t_x)$
	      \end{itemize}  
	    \pause
	    \item so $\llbracket e_1 \rrbracket_X (t_x) \neq \llbracket e_2 \rrbracket_X (t_x)$
	    \pause
	    \item most interesting case is when both evaluations are $\neq \perp$
	    \item then (by \texttt{mvSubst\_discrim}) we can find $\sigma'$ s.t.
	      all $\sigma'(x) \in T_1$ and 
	      $(\llbracket e_1 \rrbracket_X (t_x))\sigma' \neq (\llbracket e_2 \rrbracket_X (t_x)) \sigma'$
	    \pause
	    \item let $t' = t_x \sigma'$; we have $t' \in T_{N+1}$ and 
	      $\llbracket e_1 \rrbracket (t') \neq \llbracket e_2 \rrbracket (t')$. \qed
	  \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Test Set Size Bound -- Tight}
  \begin{itemize}
    \item We cannot substantially improve the size of the test set 
    (if we consider programs in the whole class $E^{nf}_N$ for some $N$).
    More specifically: 
    $\forall N \in \mathbb{N}, \exists e_1, e_2 \in E^{nf}_{N+1}$, s.t.
    $\forall t \in T_{N+1}, \llbracket e_1 \rrbracket (t) = \llbracket e_2 \rrbracket (t)$ and
    $\exists t \in T, \llbracket e_1 \rrbracket (t) \neq \llbracket e_2 \rrbracket (t)$
	\item Proof hint: it suffices to take:
	  \[\begin{array}{lclr}
	  e_1 & = & \texttt{hd} \circ e & \\
	  e_2 & = & \texttt{tl} \circ e, & \text{where:} \\
	  e & = & \underbrace{\texttt{hd} \circ \ldots \circ \texttt{hd}}_{N \text{ times}}
	  \end{array}
	  \]      
  \end{itemize}
\end{frame}

\section{Applications, Future Work}

\subsection{Deciding Program Equivalence}

% https://oeis.org/A003095 - Number of binary trees of height less than n

\subsection{Testing a Turing-complete Language}

\subsection{Related Work, Conclusions} % ???

\end{document}