\documentclass{beamer}

\usepackage{amsfonts} % for \mathbb{...}
\usepackage{stmaryrd} % for \llbracket, ...

\usepackage{tikz}
\usetikzlibrary{calc} % for (let \p1= ... in ...)

\title{Finite Test Sets for a Class of Simple Programs on Binary Trees}
\author{Dimitur Krustev}

\pgfdeclareimage[height=0.7cm]{mylogo1}{IgeXaoLogo.png}

\institute[IGE+XAO Balkan]
{
  IGE+XAO Balkan \\ \vspace{0.3cm} \pgfuseimage{mylogo1}
}

\date[ATCS 2015]{12 June 2015 / ATCS 2015}

\begin{document}

\begin{frame}
\maketitle
\end{frame}

\begin{frame}[Outline]
  \tableofcontents
\end{frame}

\section{Preliminaries}

\subsection{Binary Trees as a Universal Data Structure}

\begin{frame}[Unlabeled Binary Trees]
  \frametitle{Unlabeled Binary Trees}
	\[ 
	T ~::=~ \texttt{nil} ~|~ (T ~.~ T)
	\]
  \begin{itemize}
    \item Universal data structure 
    \item built-in pairing (unlike natural numbers, bitstrings, \ldots)
    \item possible encodings:
    \begin{itemize}
	  \item $\lceil \bullet \rceil_{\text{Bool}} ~:~ \text{Bool} \rightarrow T$
	  \[
	    \begin{array}{cc}
	    \lceil \text{false} \rceil_{\text{Bool}} ~=~ \text{nil}
	    &
	    \lceil \text{true} \rceil_{\text{Bool}} ~=~ (\text{nil} ~.~ \text{nil})
	    \end{array}
	  \]
	  
	  \item $\lceil \bullet \rceil_{\mathbb{N}} ~:~ \mathbb{N} \rightarrow T$
	  \[
	    \begin{array}{cc}
	    \lceil 0 \rceil_{\mathbb{N}} ~=~ \text{nil}
	    &
	    \lceil n+1 \rceil_{\mathbb{N}} ~=~ (\text{nil} ~.~ \lceil n \rceil_{\mathbb{N}})
	    \end{array}
	  \]
	  
	  \item $\lceil \bullet \rceil_{\text{List}(X)} ~:~ \text{List}(X) \rightarrow T$
	  \[
	    \begin{array}{lcl}
	    \lceil \lbrack\rbrack \rceil_{\text{List}(X)} & ~=~ & \text{nil}
	    \\
	    \lceil \lbrack x_1, x_2, \ldots, x_n \rbrack \rceil_{\text{List}(X)} 
	      & ~=~ & (\lceil x_1 \rceil_{X} ~.~ \lceil \lbrack x_2, \ldots, x_n \rbrack \rceil_{\text{List}(X)})
	    \end{array}
	  \]
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Simple Programs on Binary Trees}

\begin{frame}
  \frametitle{Simple Programs on Binary Trees}
  \[ E ~::=~ \texttt{I} ~|~ \texttt{hd} ~|~ \texttt{tl} ~|~ \texttt{nil}
       ~|~ \texttt{cons}(E, E)
       ~|~ E \circ E
       ~|~ \texttt{ifnil}(E, E, E)  \]
  \begin{itemize}
    \item interpretation: functions from trees to trees 
      (extended with a distinct value $\perp$ denoting undefined interpretation)
  \end{itemize}
  \[
    \begin{array}{lcl}
    \llbracket \bullet \rrbracket & : & E \rightarrow T \rightarrow T_{\perp} \\
    \llbracket \texttt{I} \rrbracket(x) & = & x \\
    \llbracket \texttt{hd} \rrbracket(t_1 ~.~ t_2) & = & t_1 \\
    \llbracket \texttt{tl} \rrbracket(t_1 ~.~ t_2) & = & t_2 \\
    \llbracket \texttt{nil} \rrbracket(x) & = & \texttt{nil} \\
    \llbracket \texttt{cons}(e_1, e_2) \rrbracket(x) & = & 
        (\llbracket e_1 \rrbracket(x) ~.~ \llbracket e_2 \rrbracket(x)) \\
    \llbracket e_1 \circ e_2 \rrbracket(x) & = & 
        \llbracket e_1 \rrbracket(\llbracket e_2 \rrbracket(x)) \\
    \llbracket \texttt{ifnil}(e_1, e_2, e_3) \rrbracket(x) & = & 
        \llbracket e_2 \rrbracket(x) ~,~ \text{if} ~ \llbracket e_1 \rrbracket(x) = \texttt{nil} \\
    \llbracket \texttt{ifnil}(e_1, e_2, e_3) \rrbracket(x) & = & 
        \llbracket e_3 \rrbracket(x) ~,~ \text{if} ~ \llbracket e_1 \rrbracket(x) = (t_1 ~.~ t_2) \\
    \llbracket \ldots \rrbracket(\ldots) & = & \perp
    \end{array}  
  \]
  \begin{itemize}
    \item ``simple'' programs: no loops or recursion
  \end{itemize}
\end{frame}

\subsection{Program Normal Forms}

\begin{frame}
  \frametitle{Program Normal Forms}
  \[\begin{array}{lclr}
  E^{nf} & ~::=~ & \texttt{nil} ~|~ \texttt{cons}(E^{nf}, E^{nf}) & \\
         &       & ~|~ \mathit{Sel}_1 \circ \ldots \circ \mathit{Sel}_n & (n \ge 0) \\
         &       & ~|~ \texttt{ifnil}(\mathit{Sel}_1 \circ \ldots \circ \mathit{Sel}_n, E^{nf}, E^{nf}) & (n \ge 0) \\
  \mathit{Sel} & ~::=~ & \texttt{hd} ~|~ \texttt{tl} & 
  \end{array}
  \]
  
\end{frame}

\section{Finite Test Sets for Simple Programs}

\subsection{Program Classes by Composition Length}

\begin{frame}
  \frametitle{Program Classes by Composition Length}
  \[\begin{array}{lclr}
  E^{nf}_N & ~::=~ & \texttt{nil} ~|~ \texttt{cons}(E^{nf}_N, E^{nf}_N) & \\
         &       & ~|~ \mathit{Sel}_1 \circ \ldots \circ \mathit{Sel}_n & (0 \le n \le N) \\
         &       & ~|~ \texttt{ifnil}(\mathit{Sel}_1 \circ \ldots \circ \mathit{Sel}_n, E^{nf}_N, E^{nf}_N) & (0 \le n < N) \\
  \mathit{Sel} & ~::=~ & \texttt{hd} ~|~ \texttt{tl} & 
  \end{array}
  \]
  \pause
  \begin{itemize}
    \item $E^{nf}_N \subset E^{nf}_{N+1}$, $\bigcup_{N \in \mathbb{N}} E^{nf}_N = E^{nf}$
  \pause
    \item programs in $E^{nf}_N$ can only ``see'' at depth $\le N$ inside the input tree  
  \pause
    \item \textbf{Main result}:
    $\forall N \in \mathbb{N}, \forall e_1, e_2 \in E^{nf}_N,$ 
    $(\forall t \in T_{N+1}, \llbracket e_1 \rrbracket (t) = \llbracket e_2 \rrbracket (t))$
    $\rightarrow \forall t \in T, \llbracket e_1 \rrbracket (t) = \llbracket e_2 \rrbracket (t)$, where:
  \end{itemize}
    \[\begin{array}{lcl}
    \mathit{depth} & ~:~ & T \rightarrow \mathbb{N} \\
    \mathit{depth}(\texttt{nil}) & ~=~ & 0 \\
    \mathit{depth}(t_1 ~.~ t_2) & ~=~ & 1 + \mathit{max}(\mathit{depth}(t_1), \mathit{depth}(t_2)) \\
    T_{N} & ~=~ & \{t \in T ~|~ \mathit{depth}(t) \le N \} 
    \end{array}
    \]
\end{frame}

\subsection{Tree Decomposition by Depth}

\begin{frame}[fragile]
  \frametitle{Tree Decomposition by Depth}
  \begin{tikzpicture}[level/.style={sibling distance=60mm/#1}]
  \node[circle,draw] (root){$\bullet$}
    child {node (t1){$\vdots$}}
    child {node[circle,draw] (t2){$\bullet$}
      child {node[rectangle,draw,rounded corners] (t21){$\texttt{nil}$}}
      child {node (t22){$\vdots$}
        child {node[circle,draw] (t221){\only<1>{$\bullet$} \only<2>{$t_i$}}
          child {node (t2211){$\vdots$}}
          child {node (t2212){$\vdots$}}
        }
        child {node[circle,draw] (t222){\only<1>{$\bullet$} \only<2>{$t_j$}}
          child {node (t2221){$\vdots$}}
          child {node (t2222){$\vdots$}}
        }
      }
    };
  \draw [dotted] let \p1=(t1), \p2=(root), \p3=(t2222) in (\x1-5mm, \y2) -- (\x3+10mm, \y2);
  \draw [dotted] let \p1=(t1), \p2=(t221), \p3=(t2222) in (\x1-5mm, \y2) -- (\x3+10mm, \y2);
  \draw [<->] let \p1=(root), \p2=(t222), \p3=(t2222) in (\x3+5mm, \y1) -- node[right]{d} (\x3+5mm, \y2);
  \end{tikzpicture}
\end{frame}

\begin{frame}
  \frametitle{Tree Decomposition by Depth (cont.)}
  \begin{itemize}
    \item Trees with Variables:
	  \[
		T_X ~::=~ \texttt{nil} ~|~ (T_X ~.~ T_X) ~|~ x \qquad (x \in X)
	  \]
    \item Decomposition function: 
      $\mathit{cutAt} ~:~ \mathbb{N} \times T \rightarrow (X \rightarrow T) \times T_X$,
      $cutAt(d, t) = (\sigma, t_x)$, where:
      \begin{itemize}
	    \item $t_x$ is the tree $t$ with all nodes at depth $d$ replaced by variables from $X$
	    \item $\sigma$ is a substitution assigning the corresponding subtree to each of these variables
	  \end{itemize}
	\item Correctness of decomposition: 
	  $\forall d \in \mathbb{N}, \forall t \in T, \forall \sigma, \forall t_x,$
	  $cutAt(d, t) = (\sigma, t_x) \rightarrow t_x \sigma = t$, where:
	  \[\begin{array}{lcl}
	    \texttt{nil} \sigma & = & \texttt{nil} \\
	    (t_1 ~.~ t_2) \sigma & = & (t_1 \sigma ~.~ t_2 \sigma) \\
	    x \sigma & = & \sigma(x)
	  \end{array}
	  \]
  \end{itemize}
\end{frame}

\subsection{Existence of Finite Test Sets}

\section{Applications, Future Work}

\subsection{Deciding Program Equivalence}

\subsection{Testing a Turing-complete Language}

\subsection{Related Work} % ???

\end{document}